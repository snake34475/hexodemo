{"meta":{"title":"笑然博客","subtitle":"","description":"tengyao博客网站","author":"tengyao","url":"http://www.onestyle.top","root":"/"},"pages":[{"title":"","date":"2023-06-02T04:20:49.886Z","updated":"2023-06-02T04:20:49.886Z","comments":true,"path":"baidu_verify_codeva-IMd7k2RmpW.html","permalink":"http://www.onestyle.top/baidu_verify_codeva-IMd7k2RmpW.html","excerpt":"","text":"ce4df91251ef40755318b0db99db6678"},{"title":"","date":"2024-01-17T08:01:33.091Z","updated":"2024-01-17T08:01:33.091Z","comments":true,"path":"404.html","permalink":"http://www.onestyle.top/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"","date":"2023-06-02T06:07:03.053Z","updated":"2023-06-02T06:07:03.053Z","comments":true,"path":"baidu_verify_codeva-fjlj0dSS5S.html","permalink":"http://www.onestyle.top/baidu_verify_codeva-fjlj0dSS5S.html","excerpt":"","text":"1deec6680de5226e4843a68b2d262bf9"},{"title":"","date":"2023-06-02T04:22:29.653Z","updated":"2023-06-02T04:22:29.653Z","comments":true,"path":"googlebb5765becb3887e3.html","permalink":"http://www.onestyle.top/googlebb5765becb3887e3.html","excerpt":"","text":"google-site-verification: googlebb5765becb3887e3.html"},{"title":"所有分类","date":"2024-01-17T08:01:33.096Z","updated":"2024-01-17T08:01:33.096Z","comments":true,"path":"categories/index.html","permalink":"http://www.onestyle.top/categories/index.html","excerpt":"","text":""},{"title":"Page","date":"2013-12-26T14:52:56.000Z","updated":"2024-01-17T08:01:33.099Z","comments":true,"path":"page/index.html","permalink":"http://www.onestyle.top/page/index.html","excerpt":"","text":"This is a page test."},{"title":"我的朋友们","date":"2024-01-17T08:01:33.097Z","updated":"2024-01-17T08:01:33.097Z","comments":true,"path":"friends/index.html","permalink":"http://www.onestyle.top/friends/index.html","excerpt":"这里写友链上方的内容。","text":"这里写友链上方的内容。 这里可以写友链页面下方的文字备注，例如自己的友链规范、示例等。"},{"title":"","date":"2024-01-17T08:01:33.098Z","updated":"2024-01-17T08:01:33.098Z","comments":true,"path":"mylist/index.html","permalink":"http://www.onestyle.top/mylist/index.html","excerpt":"","text":""},{"title":"帮助","date":"2024-01-17T08:01:33.097Z","updated":"2024-01-17T08:01:33.097Z","comments":true,"path":"faqs/index.html","permalink":"http://www.onestyle.top/faqs/index.html","excerpt":"帮助文档","text":"帮助文档 此处用于问题答疑"},{"title":"所有标签","date":"2024-01-17T08:01:33.100Z","updated":"2024-01-17T08:01:33.100Z","comments":true,"path":"tags/index.html","permalink":"http://www.onestyle.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"json.parse记录一次线上bug排查","slug":"json-parse记录一次线上bug排查","date":"2024-01-24T10:04:12.000Z","updated":"2024-01-24T10:12:07.935Z","comments":true,"path":"2024/01/24/json-parse记录一次线上bug排查/","link":"","permalink":"http://www.onestyle.top/2024/01/24/json-parse%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E7%BA%BF%E4%B8%8Abug%E6%8E%92%E6%9F%A5/","excerpt":"","text":"最近项目中有一个匪夷所思的问题，业务在使用的时候，偶发性的会白屏，经常下班的时候骚扰我们，开发苦不堪言，经过长达一周的排查，仍然没有查到bug的存在，最终尝试通过添加埋点日志，记录关键信息。 现状​ 首先讲述一下现状，首先业务进入后，页面可以认为有两个按钮 跳转共享链接 打开表单弹窗按钮，点击后展示表单。 操作顺序是，页面加载后，先点击跳转共享链接，看完链接后再返回点击表单弹窗。 里面有两个重要的时间节点，一个是跳转链接之前，一个是返回到当前页面。 跳转链接之前 需要存储接口数据，接口数据包含了表单的数据 返回当前页面 请求接口数据 本地缓存无，直接使用接口数据 本地缓存有，缓存和接口数据合并，接口数据优先 返回页面的时候，点击表单弹窗 正常上来说弹窗能够正常显示，但是线上环境再点击 展示弹窗的按钮导致白屏了。整个流程如下 初步判断是整合缓存和接口数据问题，于是需要给页面添加两个埋点 页面报错异常时上报 点击打开表单的时，上报缓存数据和聚合之后的数据。 为什么不上报接口数据呢？因为当时修复bug比较紧急，观察代码发现接口直接返回的数据没有在公共变量中存储，如果需要存储改动较大，还有就是接口数据也可以从后端日志去排查 页面报错异常上报异常上报的方法有很多，通常使用一个gif图片，地址为get的请求地址+上报信息，具体的可以自行百度，此处简单叙述下 ​ 使用图片是因为加载资源里面img优先级比较低，不会阻塞其他资源，而且图片请求不会跨域，用gif是因为对比图片类型他是比较小的 1234567891011121314151617181920212223242526272829303132333435363738394041424344//utils/utils.js/** * 异常上报方法 * 希望抽离出来同步异常类和异步异常类 */function uploadError() &#123; //上报处理参数 const upload = errObj =&gt;&#123; const logUrl = &#x27;https://xxx.xxx.com/log.gif&#x27;; // 上报接口 //将obj拼接成url const queryStr = Object.entries(errObj) .map(([key, value]) =&gt; `$&#123;key&#125;=$&#123;value&#125;`) .join(&#x27;&amp;&#x27;); const oImg = new Image(); oImg.src = logUrl + &#x27;?&#x27; + encodeURIComponent(queryStr); &#125; //同步方法 function handleError(e) &#123; try &#123; let baseInfo = localStorage.getItem(&#x27;base_info&#x27;); // 域账户 let masterName = baseInfo ? JSON.parse(baseInfo)?.master_name : &#x27;&#x27;; // 域账户 let errObj = &#123; masterName: masterName,//域账户 url: window.location.href,//报错的路由，利于排查 reason: JSON.stringify(&#123; message: e?.error?.message, //报错信息 stack: e?.error?.stack,//调用栈 &#125;), message: e?.message, //报错信息 &#125;; upload(errObj) console.log(&#x27;error&#x27;, errObj); &#125; catch (err) &#123; console.log(&#x27;error&#x27;, err); &#125; &#125; window.addEventListener(&#x27;error&#x27;, handleError);//调用监听&#125;//app.js//异常上报方法 开发环境禁止上报if(![&#x27;dev&#x27;].includes(process.env.BUILD_ENV))&#123; uploadError()&#125; 点击弹窗的异常上报1234567891011//打开弹窗的操作 const open = () =&gt; &#123; setShow(!show);//控制表单的展示隐藏 if(!show)&#123; const logUrl = &#x27;https://xxx.xxx.com/log.gif&#x27;; // 上报接口 const oImg = new Image(); let initFormVal = localStorage.getItem(&#x27;initFormVal&#x27; + query?.id); oImg.src = logUrl + &#x27;?&#x27; + encodeURIComponent(`initFormVal=$&#123;initFormVal&#125;&amp;integratedData=$&#123;JSON.stringify(integratedData)&#125;`); &#125; &#125;;//initFormVal为缓存中的数据 integratedData为整合后的数据 发现问题原因通过添加以上异常上报，业务员进行操作时，又出现了白屏，此时根据业务员token与上报关键字与时间查到了相关日志，其中日志中记录的是 1https://xxx.xxx.com/log.gif?initFormVal=&amp;integratedData=null integratedData是后端接口数据和缓存的融合呀！通过查日志发现当时后端确确实实返回正常的响应了，不可能为null，同时还有一个疑问浮出水面，为什么initFormVal没有值，而不是null 正常来说如果initFormVal从json中取值时，取不到应该默认就是null，此处为’’，只说明一个问题，缓存的时候给他赋值了 那么问题大致可以定位到以下两个操作节点 缓存时 返回页面后，缓存和接口数据融合时 12345//缓存时操作 const getFormValues = () =&gt; &#123; let formVal = childRef?.current?.getFormVal() || &#x27;&#x27;; localStorage.setItem(&#x27;initFormVal&#x27; + query.id, JSON.stringify(formVal)); &#125;; 缓存时，如果子节点获取不到，那么childRef?.current?.getFormVal()就为undefind,又由于使用了或运算符，那么此时存储的是’’，那么取这个暂时看也没问题呀，然后也写入了缓存 更严格来讲，应该先判断formVal是否存在然后再去缓存，没有就不缓存。 再看一下返回页面，数据融合的代码 123456789101112131415161718const getDataFn = url =&gt; &#123; dispatch(&#123; type: url, payload: &#123; id: query.id &#125;, callback: res =&gt; &#123; if (res.ret === 1) &#123; let initFormVal = localStorage.getItem(&#x27;initFormVal&#x27; + query?.id); console.log(&#x27;initFormVal&#x27;, JSON.parse(initFormVal)); let cacheFormVal = &#123;&#125;; if (initFormVal) &#123; //initFormVal赋值给cacheFormVal，此处省略 &#125; setPricingInfo(&#123; ...cacheFormVal, ...res.data &#125;); &#125; 发现有一个console.log()，JSON.parse(‘’)会是什么？报错，果然，查异常上报日志的时候，也查到这个错误，真是一失足成千古恨，当时只是为了方便查看，打印了一下缓存数据，没想到是这个地方出现的问题 Uncaught SyntaxError: Unexpected end of JSON input JSON.parse那问题来了 json.parse什么情况会报错呢？通过查阅MDN 那么，什么是规范的JSON格式呢？我们此处再去查阅MDN 此处只列出了json的结构 很显然，传入null 是合法的，但是传入空字符是不合法的， 123456JSON = null or true or false or JSONNumber or JSONString or JSONObject or JSONArray 吐槽可能有人要吐槽，直接写JSON存储的时候格式不对不就行了吗？干什么这那么多，又是异常上报，又是贴代码？又是贴MDN的。 我在这里回答一下之所以这么写一是为了记录出错的时候出现的问题，方便下次出现类似问题能够即时复盘。 二是希望贴出自己的排错方式，新手若有不明白的可以模仿这个方式得到一些启发和思考，高手也可指出我的问题，共同成长 同样我也希望大家遇到问题的时候要记得查文档，查文档再查文档，自己遇到的问题，先文档，是不是自己理解错了，如果还不行就去stackoverflow，如果再不济就去github issue看看是否有相同的问题是不是作者的bug，如果都没有，那么好了，这个问题几乎解决不了了，此时有两个选择，要么产品接受，要么 那我走？？？","categories":[],"tags":[]},{"title":"umi2项目打包优化","slug":"umi2项目打包优化","date":"2024-01-17T09:09:28.000Z","updated":"2024-01-24T10:10:39.612Z","comments":true,"path":"2024/01/17/umi2项目打包优化/","link":"","permalink":"http://www.onestyle.top/2024/01/17/umi2%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85%E4%BC%98%E5%8C%96/","excerpt":"","text":"umi2项目打包优化最近项目再部署的时候十分漫长，尤其是修复bug的时候，总感觉项目的部署很慢，需要五分钟，公司其他后台管理项目部署仅仅需要1分钟，于是我十分不爽，想要研究一下，这玩意到底是为什么那么卡？ 自动化部署做了什么？123我们知道一般的自动化部署，通过git push 钩子触发jenkins的自动化部署事件，从而执行一系列命令由于我们公司使用的是docker部署，那么流程就如下 docker pull 镜像并启动一个容器（耗时) 拉取项目源码 执行dockerfile1. 123456789//以下为部分命令FROM hub.xxx.com/library/nginx:stable-alpineFROM hub.xxx.com/library/node:10@sha256:dac69681e3026f8a...WORKDIR /nodeCOPY package.json /nodeCOPY package-lock.json /nodeRUN --mount=type=cache,target=/node/node_modules,id=pri.. #设置缓存 以及根据环境配置一系列命令 下依赖 可以指定镜像源 （耗时) 打包 + 压缩 （耗时) 发包（耗时) 配置nginx 结束 分析我们通过分析上方做了什么，我们可以看到，耗时的主要是docker pull镜像，安装依赖，打包，压缩，发包等等 docker 和安装依赖的提速可以让docker使用内网或者国内网速较好的镜像 发包的优化就是将包压缩的足够小 这样我们仅仅剩下和打包，压缩，这三个都可以在前端项目开发时候进行调整 优化调整首先，既然前端开发框架使用的是umi，我们就应该优先从 umijs2进行查找 umi框架的优化 按需加载组件这个似乎是默认开启的 treeShaking 这个是不用说了， disableCSSSourceMap 禁用css源码映射，这个也能提升一些速度 参考-&gt;.env和环境变量,具体的配置 ESLINT 通常我们会将这个开启，但是导致打包的时候也会执行，此时我们可以直接在packjson中将 ESLINT&#x3D;1 写入运行命令中，而不是.env中 ANALYZE 分析bundle构成，线上部署要关闭 集成了webpack-bundle-analyzer SPEED_MEASURE 线上须关闭耗时，其实是集成了speed-measure-webpack-plugin COMPRESS 默认压缩 我没有使用这个我使用的另一种方案happypack 多线程压缩123采用的是`happypack, 配置了环境变量，方便进行修改 `通常webpack的插件，如果umi没有公开其配置项的话，需要从chainWebpack中调整 压缩做好只使用一种方案，例如我使用了happypack就不要使用env中的COMPRESS，否则可能耗时反增。 12345678910111213141516171819202122//config.js // &quot;happypack&quot;: &quot;^5.0.1&quot;,import HappyPack from &quot;happypack&quot;import os from &#x27;os&#x27;;export default &#123; chainWebpack(config) &#123; if(process.env.HAPPYPACK )&#123; const cpuCount = os.cpus().length; // 获取 CPU 核心数 console.log(&quot;cpuCount&quot;,cpuCount) config.plugin(&#x27;happypack&#x27;).use(HappyPack, [ &#123; id: &#x27;js&#x27;, // 根据 CPU 核心数设置线程池大小 threads: cpuCount, // 需要并行处理的 loader loaders: [&#x27;babel-loader&#x27;], &#125;, ]); &#125;&#125;&#125; 添加缓存如果线上是docker部署的，那么线上打包部署就不能够使用缓存，所以我只在本地开发环境重配置了缓存，相当于使用mfsu 123456789//config.js //添加缓存import HardSourceWebpackPlugin from &quot;hard-source-webpack-plugin&quot;chainWebpack(config) &#123; if(process.env.cacheHardSource &amp;&amp; [&quot;dev&quot;,&quot;feature1dev&quot;].includes(process.env.BUILD_ENV ) )&#123; config.plugin(&#x27;HardSourceWebpackPlugin&#x27;).use(HardSourceWebpackPlugin); &#125;&#125; 关闭进度条可以进行配置，当线上打包时，关闭滚动条，我可以提升30s左右 1config.plugins.delete(&#x27;progress&#x27;) 提出公共组件1如果使用treesharking，就不要使用这个，会有冲突，导致包更大 源码展示12345678910//.envBROWSER=noneHAPPYPACK=true ;开启多线程; COMPRESS=none;不压缩似乎能提高速度，不压缩能提高大概20scacheHardSource=1 ;本地开发使用缓存PROGRESS=none ;线上删除进度条; SPEED_MEASURE=CONSOLE ;耗时输出到控制台; ANALYZE=true ;开启可视化分析 线上须关闭！！ 12345678910111213141516171819202122232425262728293031323334353637//config.js// &quot;happypack&quot;: &quot;^5.0.1&quot;,import HappyPack from &quot;happypack&quot;import os from &#x27;os&#x27;;const isDev = process.env.cacheHardSource &amp;&amp; [&quot;dev&quot;,&quot;feature1dev&quot;].includes(process.env.BUILD_ENV)export default &#123; treeSharking:true, disableCSSSourceMap:process.env.BUILD_ENV === &#x27;pro&#x27; ,//线上禁用源码 chainWebpack(config) &#123; //本地开发环境 if(isDev)&#123; //添加缓存，实现了过程中提高编译速度 config.plugin(&#x27;HardSourceWebpackPlugin&#x27;).use(HardSourceWebpackPlugin); // 删除进度条插件 &#125;else&#123; // 删除进度条插件 if(process.env.PROGRESS !== &#x27;none&#x27;)&#123; config.plugins.delete(&#x27;progress&#x27;) &#125; &#125; // 使用 HappyPack 插件进行多线程构建 if(process.env.HAPPYPACK)&#123; const cpuCount = os.cpus().length; // 获取 CPU 核心数 console.log(&quot;cpuCount&quot;,cpuCount) config.plugin(&#x27;happypack&#x27;).use(HappyPack, [ &#123; id: &#x27;js&#x27;, // 根据 CPU 核心数设置线程池大小 threads: cpuCount, // 需要并行处理的 loader loaders: [&#x27;babel-loader?cacheDirectory=true&#x27;], &#125;, ]); &#125;&#125;&#125; 结果展示优化前正常打包 优化后正常打包 触发运维的缓存 引用webpack4打包优化HappyPackthread-loader 玩转webpack，使你的打包速度提升百分之九十","categories":[],"tags":[]},{"title":"功夫派复刻demo","slug":"功夫派复刻demo","date":"2023-06-02T06:35:31.000Z","updated":"2024-01-17T08:01:33.094Z","comments":true,"path":"2023/06/02/功夫派复刻demo/","link":"","permalink":"http://www.onestyle.top/2023/06/02/%E5%8A%9F%E5%A4%AB%E6%B4%BE%E5%A4%8D%E5%88%BBdemo/","excerpt":"","text":"功夫派复刻demo版权归属淘米公司，如有问题，欢迎留言联系删除 感谢您使用我们的游戏demo。我们注意到，这个demo实际上是一个单机游戏，并且目前仅支持移动、打怪、捡装备、升级和存档等基本功能。由于一些历史原因，我们已经很久没有对其进行更新和维护了。同时，这个demo实际上并没有太多的技术含量，我们深感抱歉。 我们希望您能够理解，这个demo在进入游戏时可能需要加载较长时间，甚至可能需要10分钟以上的时间。这是因为我们当时使用了Unity导出的WebGL格式，为了方便用户不用下载游戏，我们并没有进行预加载和优化。目前我们的主力团队也已不再使用Unity，所以我们对这个demo没有再进行过多的维护和优化。 我们非常感谢您对我们的支持和理解，如果您在使用这个demo的过程中遇到了任何问题，欢迎随时联系我们的客户服务团队寻求帮助。同时，我们也希望能够为您提供更好的产品和服务，如果您有任何宝贵的意见和建议，也欢迎随时与我们分享。 再次感谢您的使用，祝您游戏愉快！ 场景预览城镇 关卡 装备 操作wasd移动 j攻击(捡装备) k跳跃，1使用物品 运行源码https://github.com/snake34475/kungFuPieRemakeGame 网页版http://gongfu.onestyle.top/ 本地版 下载代码中的build文件，解压后双击cangmeng.exe运行即可 百度网盘 链接：https://pan.baidu.com/s/1p2V-zKTh4FsxBjkmU3blWw?pwd=x4kj 提取码：x4kj 退出游戏由于开发进度缓慢，目前没有写退出游戏，可使用ctrl+alt+delete呼出任务栏窗口，直接杀后台即可 啰嗦两句从小对武侠充满憧憬,所以从多年前开始建立了一个属于自己的”功夫派”虚拟世界。 我和一位朋友(ZN)合作开发了这个名为”功夫派”的项目。我主要负责游戏代码部分,朋友主要为美工设计。这个虚拟的”功夫派”中的环境和人物设计和武侠世界非常相似,我可以自由选择被分到哪个派,跟着师父学习武艺,接受任务。我沉迷其中6~7年时间。 这个项目现在已临时停止更新,但我仍然会购买续费来延续这个世界。项目可供预览的网址是：gongfu.onestyle.top","categories":[],"tags":[{"name":"原创","slug":"原创","permalink":"http://www.onestyle.top/tags/%E5%8E%9F%E5%88%9B/"},{"name":"游戏","slug":"游戏","permalink":"http://www.onestyle.top/tags/%E6%B8%B8%E6%88%8F/"}]},{"title":"新昌景像素游戏","slug":"新昌景像素游戏","date":"2023-06-02T06:32:44.000Z","updated":"2024-01-17T08:01:33.095Z","comments":true,"path":"2023/06/02/新昌景像素游戏/","link":"","permalink":"http://www.onestyle.top/2023/06/02/%E6%96%B0%E6%98%8C%E6%99%AF%E5%83%8F%E7%B4%A0%E6%B8%B8%E6%88%8F/","excerpt":"","text":"像素风的冒险战斗游戏这是一款古风即时战斗游戏，玩家扮演一位龙人，在一个虚构的冒险世界中探索。游戏的背景设定在一个名为新昌景的城镇地图上，玩家可以与各种NPC进行交互，包括桃花、小溪、雪山和岩浆等地形。此外，游戏还提供多个地牢探索，让玩家可以挑战更多的关卡。在游戏中，玩家需要运用自己的策略和技巧来克服各种难关，不断提升自己的实力和技能，成为真正的冒险家。 场景预览 npc 旱魃图 冰雪地形 岩浆地形 小溪 操作wasd 运行网页版http://resetseer.onestyle.top/ 网页版加载特别慢，推荐使用本地版 源码地址https://github.com/snake34475/pixelWindDragonGame/tree/main 本地版 下载代码中的pixelWindDragonGame.zip文件，解压后双击cangmeng.exe运行即可 百度网盘分享 链接：https://pan.baidu.com/s/1GL9Onbat3DqYOqWYsSYn_g?pwd=7piz 提取码：7piz 退出游戏由于开发进度缓慢，目前没有写退出游戏，可使用ctrl+alt+delete呼出任务栏窗口，直接杀后台即可","categories":[],"tags":[{"name":"原创","slug":"原创","permalink":"http://www.onestyle.top/tags/%E5%8E%9F%E5%88%9B/"},{"name":"游戏","slug":"游戏","permalink":"http://www.onestyle.top/tags/%E6%B8%B8%E6%88%8F/"}]},{"title":"vant选择器组件添加鼠标滚轮","slug":"vant选择器组件添加鼠标滚轮","date":"2023-05-26T05:48:32.000Z","updated":"2024-01-17T08:01:33.093Z","comments":true,"path":"2023/05/26/vant选择器组件添加鼠标滚轮/","link":"","permalink":"http://www.onestyle.top/2023/05/26/vant%E9%80%89%E6%8B%A9%E5%99%A8%E7%BB%84%E4%BB%B6%E6%B7%BB%E5%8A%A0%E9%BC%A0%E6%A0%87%E6%BB%9A%E8%BD%AE/","excerpt":"","text":"背景平常做前端开发的应该知道，在前端组件中，有两种组件 一种是针对移动端的组件 另一种是针对pc的组件 ​ 而pc的组件主要是对鼠标，键盘等操作的支持，而移动端组件常用的事件是触摸等事件 ​ 这时，狗血的就来了，业务总是能用各种奇怪的想法让你来回串着开发 ​ 我们有一款web是写在企业微信内部的h5网页，他使用的是移动端组件，但是这个应用由于企业微信手机端和电脑端都有，导致了业务也会用电脑操作的需求 ​ 这天，他说选项组件为什么不能使用滚轮选择？而是只能使用拖拽？这样不好用，要改成也支持滚轮 解决路径 嫌麻烦，请直接跳到最后的解决方案，前面只是解决路程 vant组件库​ 首先咱们就去看这个组件，也就是 vant官方库,他有一个能够兼容桌面的​ 这咱们一看就来劲儿了呀，正好咱们要用鼠标滚轮，肯定能够实现鼠标滚轮模拟拖拽呀，咱们继续往下看下去 ​ 然后发现本地项目中已经安了这个插件，但是滚轮效果仍然不生效，于是乎，这种方法不可以 gihtub issues​ 当然，如果咱们只会查文档解决问题那么咱们就不是合格的程序员了，咱们也要学会去源码项目的issues，于是咱们去看下vant项目源码 ​ 看到关于滚轮的有19个已解决，咱们就开心了，看来前人已经把路子探好了，咱们直接copy就行了 ​ 然后看到开发大大的回答就哭了，没计划支持，以后也不会支持， CSDN​ csdn回答 这种方法也时候也能解决一些问题，但是他通过改node_modules解决的，这种方法涉及到如何把源码包抽离出来，进行更改，然后所有的引入源也更改，比较麻烦，而且害怕涉及到线上问题 hammerjs​ 再后来就想着使用hammerjs模拟手指操作可以么？滚轮滚一个，然后模拟手指滑动多少距离，这样就不用麻烦判断边界问题和选中问题，但是通过引入hammerjs问题频频。例如获取dom的麻烦等等问题，并且无法监听你是否能够监听你是否模拟成功了，所以这种也不行 换组件！！​ 换组件的话意味着重写，开发周期起码两天以上，这种特别麻烦 ​ 我尝试使用 Mint UI Cube UI Vux MUI 等等，但是都没发现，突然我想看看antd-mobile，哭了，发现他有，但是他是react组件，vue和react串着写，肯定不可能呀 chatGPT(解决方案1)改组件​ 其实上面换组件，和使用hammerjs都是他给我推荐的，可能是关键词不行？后来一个解决方法不用换组件，可以在原生写 原回答如下 在 mounted 钩子函数中，获取到 Picker 组件的 DOM 元素，并添加 wheel 事件监听函数。 在 wheel 事件监听函数中，根据鼠标滚轮滚动的方向来修改 Picker 组件的选中值。可以通过调用 scrollToOption 方法来实现滚动选中值的效果。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;template&gt; &lt;div&gt; &lt;van-picker ref=&quot;picker&quot; :columns=&quot;columns&quot; @change=&quot;handleChange&quot; :default-index=&quot;currentIndex&quot; /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; // 如果不是v2记得把 :default-index=&quot;currentIndex&quot;属性删掉，虽然我也不知道会出现什么错误import &#123; Picker &#125; from &#x27;vant&#x27;;export default &#123; components: &#123; [VanPicker.name]: Picker, &#125;, data() &#123; return &#123; columns: [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;E&#x27;], currentIndex: 0 &#125;; &#125;, mounted() &#123; //获取到picker的dom //如果咱们在pouop里面写的话，就应该写到当弹窗出来再获取dom，否则获取不出来 const pickerEl = this.$refs.picker.$el; pickerEl.addEventListener(&#x27;wheel&#x27;, this.handleWheel); &#125;, methods: &#123; handleChange(value, index) &#123; this.currentIndex = index; console.log(&#x27;Selected value(value, index)&#x27;, value, index); &#125;, handleWheel(event) &#123; event.preventDefault(); //Math.sign()函数，返回+/-1，表示正数还是负数，例如deltaY发现是-100，那么Math.sign返回也是-1，但是传入0那就是0 const delta = Math.sign(event.deltaY); //获取最大下标 const maxIndex = this.columns.length - 1; //计算当前下标，因为滚轮和拖拽是相反的逻辑，我们可以试下，触控板和鼠标滚轮就是相反的，所以要减 const newIndex = this.currentIndex - delta; //边界处理 if (newIndex &gt;= 0 &amp;&amp; newIndex &lt;= maxIndex) &#123; this.currentIndex = newIndex; //动画可能不流畅 //vant 4的话 this.$refs.picker.scrollToOption(newIndex); //vant3 this.$refs.picker.scrollToOption(newIndex); //vant2 的解决方案，我是以下的解决方法解决的 //这个是控制动画的时长 // this.$refs.picker.$el.getElementsByClassName(&#x27;van-picker-column__wrapper&#x27;)[0].style.transitionDuration=&#x27;800ms&#x27; //这个是给哪个变化添加属性，由于省事就添加all //this.$refs.picker.$el.getElementsByClassName(&#x27;van-picker-column__wrapper&#x27;)[0].style.transitionProperty=&#x27;all&#x27; &#125; &#125; &#125;,&#125;;&lt;/script&gt; ​ 在这个示例中，我们在 mounted 钩子函数中获取到了 Picker 组件的 DOM 元素，并添加了 wheel 事件监听函数。在 handleWheel 方法中，我们根据鼠标滚轮滚动的方向来修改 Picker 组件的选中值，并调用 scrollToOption 方法来实现滚动选中值的效果。最后，我们在 handleChange 方法中输出了选中的值和索引。 需要注意的是，在 handleWheel 方法中，我们调用了 event.preventDefault() 来阻止浏览器默认的滚动行为，以避免与 Picker 组件的滚动效果冲突。 如何全局生效？使用混入，以下是全部代码，我的vant是2版本 12345678910111213141516171819202122232425262728293031323334353637383940// mixins.js 文件//1.picker组件需要添加ref//2.骗export const myMixin = &#123; methods: &#123; //这个事件放到picker弹出的地方 /*** * picker滚动事件 * @param picker picker的ref * @param cloum picker的数据 * @param getCurFn 默认选中的index,是一个函数，因为需要拿到实时的 * @param setIndex 设置index的方法 * @returns &#123;Promise&lt;void&gt;&#125; */ async getpicker(picker,cloum,getCurFn,setIndex)&#123; await new Promise(resolve =&gt; &#123;setTimeout(resolve,100)&#125;) const pickerEl = this.$refs[picker].$el; pickerEl.addEventListener(&#x27;wheel&#x27;, (event)=&gt;this.handleWheel(event,picker,cloum,getCurFn,setIndex)); // console.log(&quot;pickerEl&quot;,pickerEl) &#125;, handleWheel(event,picker,cloum,getCurFn,setIndex) &#123; // debugger event.preventDefault(); const delta = Math.sign(event.deltaY); // debugger const maxIndex = cloum.length - 1; const newIndex = getCurFn() + delta; // debugger this.$refs[picker].$el.getElementsByClassName(&#x27;van-picker-column__wrapper&#x27;)[0].style.transitionDuration=&#x27;800ms&#x27; this.$refs[picker].$el.getElementsByClassName(&#x27;van-picker-column__wrapper&#x27;)[0].style.transitionProperty=&#x27;all&#x27; if (newIndex &gt;= 0 &amp;&amp; newIndex &lt;= maxIndex) &#123; // this.popupData.defaultIndex = newIndex; // console.log(&quot; setIndex&quot;, setIndex,newIndex) setIndex(newIndex) &#125; &#125;, &#125;&#125;; 调用（需要再全部引用的地方都调用） 1this.getpicker(&#x27;picker&#x27;,this.popupData.comSurList,()=&gt;this.popupData.defaultIndex,(index)=&gt;this.popupData.defaultIndex=index) 我们能够看到他的缺点了，需要再所有的地方都去调用一次 依赖包打补丁(最终解决，最简单)更新vant到最新版本​ 更新vant之后，我们可以发现vant的picker组件已经支持滚动滑轮了，但是每个滑轮滑动的过大，可能一次跳过两个选项，我们要进行修改 改源码​ 改源码的方式有以下几种 提issues等待作者更新（莫不是在开玩笑） 将源码粘贴到component文件，然后全局改引用的位置（有一点点麻烦，项目也会变大，也有通过在webpack添加alis添加别名直接全局修改引用） 将源码仓库fork到自己的仓库，然后修改源码后，然后在自己项目中的npm修改一下包的位置后面的rep改成自己仓库的地址（但是记住千万别删这个仓库，否则以后你的项目就启不起来了） 通过patch-package对源码包打补丁 可以先了解一下patch-package 的介绍 说白了就三步 装依赖 直接改源码 执行命令将改的源码变成diff文件 packagejson添加钩子执行 安装一下patch package123npm i patch-packageyarn add patch-package postinstall-postinstall 改源码目录 node_modules-&gt;vant-&gt;picker-&gt;PickerColumn.js 在node_modules中找到vant（注意不是@vant，那个可能是vant的一些补丁包） 可以看到他的以下结构 全局搜索一下wheel，找到onMouseWheel的方法，可以除以一个倍数，让其流畅 编译补丁1npx patch-package package-name 此时我们可以看到根目录已经添加了一个patches文件了，查看文件发现是我们修改的相关位置 添加钩子默认会在packagejson中scripts添加一个钩子函数 1&quot;postinstall&quot;: &quot;patch-package&quot;, 他的意思是安装依赖的时候立马支持patch-package打补丁 此时就可以测试一下，将node_modules删除后测试一下是否成功了 异常解决pm WARN lifecycle &#x78;&#120;&#x78;&#x2e;&#x78;&#x78;&#x78;&#x2e;&#x63;&#111;&#109;&#64;&#48;&#46;&#x31;&#46;&#x30;~postinstall: cannot run in wd &#x78;&#120;&#x78;&#46;&#120;&#x78;&#120;&#x2e;&#x63;&#111;&#109;&#64;&#48;&#46;&#49;&#x2e;&#48; patch-package (wd&#x3D;&#x2F;node) 我们部署线上的时候可能会出问题，因为有的docker安装依赖的时候工作目录可能不一致，可以尝试将钩子函数添加一个打包前执行,此时就会正常执行了 1&quot;prebuild&quot;: &quot;patch-package&quot;, 由于项目可能需要有不同环境的打包命令，所以可以以下 12345678 //开发环境需要&quot;postinstall&quot;: &quot;patch-package&quot;,//打包需要 &quot;prebuild&quot;: &quot;patch-package&quot;, &quot;prebuild:test&quot;: &quot;patch-package&quot;, &quot;prebuild:feature1&quot;: &quot;patch-package&quot;, &quot;prebuild:feature2&quot;: &quot;patch-package&quot;, &quot;prebuild:prod&quot;: &quot;patch-package&quot; 于此，这项目就可以告别一段落","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"http://www.onestyle.top/tags/vue/"},{"name":"js","slug":"js","permalink":"http://www.onestyle.top/tags/js/"},{"name":"mixin","slug":"mixin","permalink":"http://www.onestyle.top/tags/mixin/"},{"name":"patch-package","slug":"patch-package","permalink":"http://www.onestyle.top/tags/patch-package/"},{"name":"原创","slug":"原创","permalink":"http://www.onestyle.top/tags/%E5%8E%9F%E5%88%9B/"}]},{"title":"局域网穿透","slug":"局域网穿透","date":"2023-05-24T03:14:15.000Z","updated":"2024-01-17T08:01:33.094Z","comments":true,"path":"2023/05/24/局域网穿透/","link":"","permalink":"http://www.onestyle.top/2023/05/24/%E5%B1%80%E5%9F%9F%E7%BD%91%E7%A9%BF%E9%80%8F/","excerpt":"","text":"准备 本地一个电脑 一个具有公网ip的服务器或电脑 原理 本地和服务器搭建局域网,搭建完成后可以认为可以互相访问，但是外网无法访问本地的端口 服务器具有公网ip，也可以搭建服务，可以使用nginx对局域网端口进行转发 搭建局域网具体教程可以看 局域网管理页面 zerotier linux安装123456#下载curl -s https://install.zerotier.com | sudo bash#启动。可能显示9993端口占用，不用管，但是记得防火墙把9993端口打开zerotier-one -d#连接局域网 这个ip去zeroiter去看sudo zerotier-cli join xxxxxxxxxxxxxxxx 宝塔进行代理添加站点，域名记得解析一下，文件夹也不用新建直接提交 点击刚刚添加的网站-》设置,找到反向代理，添加反向代理 代理名称必填，随便写一个就行了，目标URL输入内网ip和端口，其他的不用改直接提交 答疑 流量使用的是服务器，所以访问量过大，流量用完了，服务器和本地都不能访问了 有带宽限制，因为用的他们的服务器搭建的局域网，如果有更高要求其实可以使用开源的node开发的局域网穿透 用途有服务器和公网ip这样你就拥有一个更大存储空间的服务器了（虽然流量有限制），如果是轻量云的话流量会有限制，像是华为的或者其他正经服务器的话，流量是没有限制的，所以几乎可以不考虑这个问题 我通常部署ai项目，例如stable diffusion，因为这个项目对显卡十分有要求，一般服务器如果带显卡的话非常贵，一个月估计要上千不等，但是我本地电脑的性能相对强悍（3070），因此为了不浪费他的性能，完全可以使用穿透一下解决 没有公网ip没有公网ip只有局域网的话，可以实现局域网联调项目 例如a写一个前端服务，b写一个后端服务，但是你们都没有公网ip,但是此时通过上方搭建虚拟网络就可以实现联调了，只要你们互相写成你们局域网ip和端口","categories":[],"tags":[{"name":"网络","slug":"网络","permalink":"http://www.onestyle.top/tags/%E7%BD%91%E7%BB%9C/"},{"name":"宝塔","slug":"宝塔","permalink":"http://www.onestyle.top/tags/%E5%AE%9D%E5%A1%94/"},{"name":"运维","slug":"运维","permalink":"http://www.onestyle.top/tags/%E8%BF%90%E7%BB%B4/"}]},{"title":"chatGLM部署运行","slug":"chatGLM部署运行","date":"2023-05-24T03:02:15.000Z","updated":"2024-01-17T08:01:33.091Z","comments":true,"path":"2023/05/24/chatGLM部署运行/","link":"","permalink":"http://www.onestyle.top/2023/05/24/chatGLM%E9%83%A8%E7%BD%B2%E8%BF%90%E8%A1%8C/","excerpt":"","text":"下载百度网盘下载 链接 打开后将所有的包解压，我们可以看到打开3-20日更新这个包,可以看到chatglm-6b这个文件夹，将这个文件夹内部的所有文件拷贝覆盖到model文件中的chatglm-6b中将解压好的model放到ChatGLM-webui文件中 将环境包内部的文件粘贴到ChatGLM-webui文件中g最终展示为此时点下强制更新，更新下最新代码 然后根据自己的显存选项选择使用哪个脚本8g的显存点击运行，这种就是成功的情况 报错分析第一种 点击同文件下的install.sh尝试 重新按照以上步骤安装 重启电脑 Symbol cudaLaunchKernel not found可以尝试不管他，多等一会，出现网址说明就能用 这种一般是int4 也就是显存小于8g的时候的报错，需要单独安装 cuda","categories":[],"tags":[{"name":"chatgpt","slug":"chatgpt","permalink":"http://www.onestyle.top/tags/chatgpt/"},{"name":"AI","slug":"AI","permalink":"http://www.onestyle.top/tags/AI/"}]},{"title":"远程办公","slug":"远程办公","date":"2023-05-24T02:48:53.000Z","updated":"2024-01-17T08:01:33.095Z","comments":true,"path":"2023/05/24/远程办公/","link":"","permalink":"http://www.onestyle.top/2023/05/24/%E8%BF%9C%E7%A8%8B%E5%8A%9E%E5%85%AC/","excerpt":"","text":"远程办公篇 文章仅仅针对安卓手机和win电脑,最好使用有线网络，无线网络未测试 ​ 所需设备：两台电脑 ，一台安卓手机，公司有内网vpn ​ 由于不想背电脑回家，但是回家之后公司让改几个bug或者自己急需公司电脑操作一些东西只有公司电脑有，并且家中有一台电脑 ​ 电脑远程控制的软件很多，更何况现在云游戏的盛行，很多软件都能够支持远程办公，目前我推荐的是向日葵，免费的已经够用了 ​ 能控制了，但是开机怎么办，关机还行，系统能够点击，开机的时候什么软件都没有运行日葵可能就无法操控，目前可以实现的办法是两种： 开机进入bios，将通电后开机选项开启，然后购买一款wifi控制的智能插座，这样即时远在天涯也能进行开机，但是有缺点就是非正常关机无法进行开机，下面的方法也有这种缺陷（最简单的一种，百分之九十的电脑支持，但是部分电脑不支持，我的bios就没有，但是有解决方法，建议小白别轻易尝试） 使用wake on lan功能，电脑插入有线网络，其他端通过mac地址和ip对该电脑发送数据包从而进行开机 内网环境 即可进行开机 外网环境 若公司又vpn，连接vpn即可进行开机 需要公网ip，并且路由器绑定ip即可（较难） 物理开机 物理装置开机，通过3d打印一个按键，控制点击开机键物理开机 雇个人给你开关机 外置 淘宝跳线，原理是一根线连接主板和供电中间控制一下，一般台式机用 usb控制开关机，淘宝有售 待补充 向日葵设置​ 1.最好登录账号，登录账号之后，名下所有设备皆可见 电脑端开机自启打开 第一次可能需要设置一次向日葵的访问密码 有的笔记本有登录密码但是不影响，向日葵也能进行控制输入密码，如若此时手机内向日葵控制中此电脑没有显示在线，则输入密码看是否有以下提醒，则需要通过这种方法进行解决 电脑如果开火绒了或者其他杀毒管家类软件，需要把向日葵的自启打开 重启测试 远程开机​ 由于我电脑的bios中不支持通电开机，又不想花钱的路线，需要公司支持vpn办公 电脑配置以下是三个较好的文档分享 https://www.jianshu.com/p/d89b5560c3ed https://zhuanlan.zhihu.com/p/469645198 https://www.iplaysoft.com/wol.html 能解决部分问题 大体就是 bios设置网络唤醒打开 设备管理器中的找到Inter和Realtek开头的 关闭快速开机 手机和电脑都下载wake on lan 手机上填写电脑有线网的mac地址和ip （cmd中 ipconfig &#x2F;all进行查看） 电脑打开wake on lan，点击封包监控诊断工具 手机点击wake on lan该设备 7.电脑收到信号，说明成功，此时关机，再次用手机唤醒，此时就能正常开机 8.但是只完成了局域网的开机，如果公司有vpn，在外面的时候，用手机或电脑连接公司的vpn仍然可以通过这种方式进行开机 电脑端软件 网络唤醒wake on lan安卓软件 wake on lan 这个比较好用 密码7741 扩展远程开机棒 这个软件能够通过qq 微信，邮箱等一系列通知进行开机，但是需要一个备用机一直放到电脑旁边，但是我局域网都无法进行连接，希望高手协助","categories":[],"tags":[{"name":"网络","slug":"网络","permalink":"http://www.onestyle.top/tags/%E7%BD%91%E7%BB%9C/"},{"name":"硬件","slug":"硬件","permalink":"http://www.onestyle.top/tags/%E7%A1%AC%E4%BB%B6/"}]},{"title":"sonar代码审查","slug":"sonar代码审查","date":"2023-01-13T06:11:05.000Z","updated":"2024-01-17T08:01:33.093Z","comments":true,"path":"2023/01/13/sonar代码审查/","link":"","permalink":"http://www.onestyle.top/2023/01/13/sonar%E4%BB%A3%E7%A0%81%E5%AE%A1%E6%9F%A5/","excerpt":"","text":"window安装sonaar 最好使用docker装，因为需要java特定环境， docker安装方法安装sonarqube官网教学 因为官网某些地方没有成功运行，以下是成功运行的步骤 ​ 1.首先本地有docker，docker配置下阿里云镜像 ​ 阿里云镜像配置指南 ​ 2.拉取镜像 1$ docker pull sonarqube ​ 3.运行镜像,官网那种方法我没有看懂，我使用了可视化运行 ​ 4.打开http://localhost:9000/，进行登录,初始密码和账号都为admin ​ 5.安装中文，第一次进入插件上方有一个提示点击后才能安装 安装sonar-scannersonarScanner官网教程，docker方法没有试，我于window64位安装解压后，环境变量path添加bin之后安装成功 创建项目 之后点击继续，其他按照教学走就可以 ​ 8.窗口运行之后返回http://localhost:9000/页面，可以看到bug","categories":[],"tags":[]},{"title":"同步笔记的几种方式","slug":"同步笔记的几种方式","date":"2022-10-14T10:25:57.000Z","updated":"2024-01-17T08:01:33.094Z","comments":true,"path":"2022/10/14/同步笔记的几种方式/","link":"","permalink":"http://www.onestyle.top/2022/10/14/%E5%90%8C%E6%AD%A5%E7%AC%94%E8%AE%B0%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"开发效率软件","slug":"开发效率软件","date":"2022-10-14T09:59:52.000Z","updated":"2024-01-17T08:01:33.094Z","comments":true,"path":"2022/10/14/开发效率软件/","link":"","permalink":"http://www.onestyle.top/2022/10/14/%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E8%BD%AF%E4%BB%B6/","excerpt":"","text":"cover一款window文件系统折叠标签页的软件，缺点是肯定比原生卡顿，原开发者将他卖给第三方，第三方一直植入病毒并且要不回来，建议断网使用 下载：从网上直接搜索 2.wox快速检索window软件，类似iphone的搜索功能，快捷键alt+space，在github中有开源项目和evething搭配能够搜索文件 3.everything一款快速检索查找文件的软件，速度特别快 4.命令框合并cmder管理命令框神器，支持命令框的切换和折叠，安装后似乎是继承了cmd，不过要提醒一句，进入d盘输入 1234567891011$ d:/ # 就可以进入了# 常用快捷键# 打开命令框shift + alt +number- 1 #cmd命令- 2 # powershell#切换ctrl+number chrome插件，能够让你的chrome通过vim快捷键方式进行操作，十分顺滑 搜索vimium，安装之后通过 12345678? #快捷键呼叫出vim的提示hjkl 左下上右HL 后退 前进KL tab切换o O 搜索地址栏小写是cur和newi 光标 f F 标记每个按钮一个字符然后进入 只截取了部分的图片 不得不提一下这个的f模式，点f后在每个超链接上自动标记几个字母，从而实现脱离鼠标","categories":[{"name":"软件","slug":"软件","permalink":"http://www.onestyle.top/categories/%E8%BD%AF%E4%BB%B6/"}],"tags":[]},{"title":"webstrom使用指南和vscode对比","slug":"webstrom使用指南和vscode对比","date":"2022-10-14T06:25:30.000Z","updated":"2024-01-17T08:01:33.093Z","comments":true,"path":"2022/10/14/webstrom使用指南和vscode对比/","link":"","permalink":"http://www.onestyle.top/2022/10/14/webstrom%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97%E5%92%8Cvscode%E5%AF%B9%E6%AF%94/","excerpt":"","text":"我是占位符---","categories":[{"name":"软件","slug":"软件","permalink":"http://www.onestyle.top/categories/%E8%BD%AF%E4%BB%B6/"}],"tags":[]},{"title":"番茄闹钟","slug":"番茄闹钟","date":"2022-10-08T07:18:39.000Z","updated":"2024-01-17T08:01:33.095Z","comments":true,"path":"2022/10/08/番茄闹钟/","link":"","permalink":"http://www.onestyle.top/2022/10/08/%E7%95%AA%E8%8C%84%E9%97%B9%E9%92%9F/","excerpt":"","text":"​ 番茄工作法让我们保持和自己的对话，观察自己而不是欺骗自己。在任何时候，如果你发现自己在发短信而不是专心完成目标，别担心，因为下一个番茄工作时间会更顺利。请对自己温柔点 ​ 对于很多人来说，时间就是敌人，截止日期逼近的时候，学习效率低下，发展成了拖延症，使用番茄工作法，正视工作和学习，时间是盟友，我们用自己方法去完成并不断提高自己的学习效率 关于我们个人目标 1 计算时间 一个番茄时间必须有始有终（在一个番茄闹钟未完成时不休息，这段时间是你的超量学习时间，在闹钟响后，放下手头的事情，去整合下大脑让他去休息，哪怕你感觉立马就要完成这件事情了） 在休息的时候一定要放松，不要做消耗脑力的事情 每四个番茄闹钟是一组，这一组之后可以休息 15-30 分钟，可以简单的休息一下 每天记下来这些花费的番茄数量，第二天反思如何更短时间完成同样质量的内容 目标 2 减少干扰内在因素 遇到突发事件，询问自己是非必须要打断番茄闹钟去做这件事，如果是那就暂停，如果不是，那就拖到一小时后去做 减少干扰的首要任务是意识到内生干扰的数量和类型，观察这些干扰，接受他们，安排他们，或者删除他们 外在因素 有干扰记录在活动清单，或者计划外紧急的一栏，并写入截止日期，等自己的任务完成之后再去处理 通过记录反思和总结，逐步去减少意外的干扰 目标 3 预测所需多少功夫​ 对一项活动所需花费多少功夫去预测，和平时项目中的计算工时相同 番茄钟最小单位是 1 个，不得以小数出现 如果活动过大，就进行拆解，如果过小就找活动清单相同的任务进行合并 根据实际完成时间和预测，判断自己是提前完成还是超时完成(当超时时，重新预测自己需要再花多少个番茄时)目的是控制整体误差，还有防止第二次预测的出现从而将误差控制到最小 目标 4 让番茄时间更高效​ 若完成以上，则可以升级番茄工作法 番茄时间结构 在每个番茄时间开始前三分钟用来复习，后三分钟时间用来复习这段时间学的东西 番茄实践组 如果以四个番茄为一组，那么可以使用最后一个番茄进行复习 系统的重复和修改能够提高“过度学习”的效果，有助于获取新知识 目标 5 制作时间表​ 你要定义和尊重一张时间表，绝不能低估他的重要性 原文举例较多，意思是在你使用番茄时间的时候要考虑好执行他的时间段，例如你每天计划是 8 个番茄，之前你都是从早上七点开始，但是今天你从下午两点才开始， 此时就不能严格去按照 8 个番茄去执行从而造成加班的无限恶性循环 时间表总是优先于番茄时间。 定义一下上午工作时间，下午工作时间能够使用的番茄最大数量 目标 六 定义你个人的提升目标​ 记录这个文章需要使用几天 达成团队目标(暂时不感兴趣)结果变化休息时间不要为了工作而去压榨自己得休息时间，这样会让自己感觉到疲惫，正常是使用番茄一组之后休息 25 分钟，这样做得目的不是必须休息 25，而是保障泥不会超过 30 分钟，如同马拉松长跑，在一组没有完成之前不要休息太久 要学到得一件事是看起来快 不重要，达到快才重要，学会测量自己，观察自己得速度，认识到持续的价值 完成一件事，如果需要 4 个番茄，期望在 2 格内完成不是重要得，重要的是如何压缩 在工作中区去跟踪，观察，根据需要分析自己和自我提升，不断去压缩花费得时间，但不要走捷径 你一天完成多少个番茄时间并不重要，重要得是如何连续的完成多个番茄时间，就是上方说的马拉松长跑，目标是终点 法则1.一个番茄时间包括 25 分钟的工作时间和 5 分钟的休息时间。 2.每完成 4 个番茄时间，休息 15 到 30 分钟。 3.一个番茄时间不可分割。没有所谓的半个番茄时间或四分之一个番茄 时间。 4.一个番茄时间必须有始有终。 5.如果一个番茄时间被不停中断，则该番茄时间作废。 6.如果在一个番茄时间没结束就完成了任务，请检查、回顾任务，直到 定时器响起。 7.保护番茄工作法。及时告知对方（你目前没有时间），迅速协商、重 新安排中断事件并按照协商时间回复来找你的人。 8.如果任务预计要花超过 5 到 7 个番茄工作时间，将它分解开来。将复杂 的任务分解成几个小任务。 9.如果任务预计所花时间不够一个番茄工作时间，把它们累积起来。 10.结果是一个又一个番茄时间的累积。 11.时间表总是优先于番茄工作时间。 12.一个小队，一个番茄时间。 13.下一个番茄时间会更顺利 参考番茄工作法（(弗朗西斯科·西里洛 [弗朗西斯… ）","categories":[{"name":"学习方法","slug":"学习方法","permalink":"http://www.onestyle.top/categories/%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"}],"tags":[]},{"title":"微信小程序客服功能","slug":"微信小程序客服功能","date":"2022-08-29T08:45:43.000Z","updated":"2024-01-17T08:01:33.095Z","comments":true,"path":"2022/08/29/微信小程序客服功能/","link":"","permalink":"http://www.onestyle.top/2022/08/29/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AE%A2%E6%9C%8D%E5%8A%9F%E8%83%BD/","excerpt":"","text":"用户如何和客服聊天​ 1.小程序中，通过开发者提供的消息按钮​ 2.已和客服交谈过，可以在微信对话，小程序客服消息中找到 客服怎么给用户聊天​ 1.调用发送客服消息接口​ 2.使用网页端微信小程序客服或者授权给第三方平台​ 3.使用移动端 微信小助手 应用程序 客服下发条件​ 通俗就是，客服可以回消息的限制，以下是官方的限制 用户动作 允许下发条数限制 下发时限 用户发送信息 5条 48小时 ​ 每次用户发送一次消息之后，客服最多回复5条消息并且需要在48小时内，超过就会返回报错 45047 — 客服接口下行条数超过上限 ​ 说到先提条件用户发消息，也就说当用户点进去微信客服的时候，他不发送消息，你想发句问候，是不支持的 调用客服消息接口发送客服消息​ 使用客服消息，微信服务器会将消息post到开发者填写的url，开发者收到进行异步回复，若授权第三方则直接到第三方，推送配置详细看消息推送配置 网页端客服工具与移动端小程序客服工具​ 如果客服消息权限授权第三方，所有消息推送到第三方服务器，不在推送开发者的服务器或推送到网页版客服工具 客服通过客服消息进入会话事件 不会转发客服工具，此前也提到，用户不发消息，客服也无法发消息 客服使用添加客服人员​ 使用网页端与移动端小程序客服工具前，小程序管理员需在小程序后台 完成客服人员的绑定。目前小程序支持绑定不多于100个客服人员。 客服登录使用​ 搜索客服小助手小程序，登陆后可接入对话 ​ 网页点上方的链接进入 客服状态在线状态下，即使退出小程序，仍然可以收到消息离线后不能 会话 待接入的会话(用户找客服，还没有客服回复，处于折叠状态，用户处于未分配状态) 已接入的会话(接入后和消息列表一样，用户可以延续对话) 接入设置(似乎是只有网页端)​ 自动接入​ 手动接入 在待接入列表中手动点 文章引用微信小程序开发官方文档之客服功能使用指南 客服接口下行条数超过上线，限制条件是什么？","categories":[],"tags":[{"name":"微信小程序","slug":"微信小程序","permalink":"http://www.onestyle.top/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"jwtForNode","slug":"jwtForNode","date":"2022-07-20T02:41:18.000Z","updated":"2024-01-17T08:01:33.092Z","comments":true,"path":"2022/07/20/jwtForNode/","link":"","permalink":"http://www.onestyle.top/2022/07/20/jwtForNode/","excerpt":"","text":"传统的用户认证cookie和session认证·1234sequenceDiagram 客户端-&gt;&gt;+服务器: 发送用户密码 服务器--&gt;&gt;+客户端: 验证成功，session存储角色信息，登陆时间，返回一个sessionid存储cookie 客户端-&gt;&gt;+服务器: 每次请求携带cookie，判断session_id得知身份 缺点 不同服务器之间不能共享session 解决方法 session持久化，写入数据库，但是缺点是工程量大 服务器不保存session数据，全部保存客户端现在的jwt jwt数据结构 Header（头部） Payload（负载） Signature（签名） header头部一般是json对象，描述jwt的算法和令牌类型，都通过base64加密 1234&#123; &quot;alg&quot;: &quot;HS256&quot;, //签名算法 &quot;typ&quot;: &quot;JWT&quot; //令牌类型&#125; payloadjson对象，用来存放需要传递数据，jwt规定7个官方字段 1234567iss (issuer)：签发人exp (expiration time)：过期时间sub (subject)：主题aud (audience)：受众nbf (Not Before)：生效时间iat (Issued At)：签发时间jti (JWT ID)：编号 除此之外还可以定义私有字段，默认不加密，不要放密码，例如 12345&#123; &quot;sub&quot;: &quot;1234567890&quot;, &quot;name&quot;: &quot;John Doe&quot;, &quot;admin&quot;: true&#125; Signature是对前两部分的签名，指定一个密钥，密钥只有服务器能够使用 node的jwt验证过程1.前端发送账号密码之后2.后端通过插件生成token3.前端请求携带token4.后端判断token有效期 本操作步骤，是在express脚手架下进行的，请自行安装 首先下载jsonwebtoken插件 1$ npm i jsonwebtoken -s 123456789101112131415161718var jwt=require(&quot;jsonwebtoken&quot;)var jwtCode=&quot;asdfasfasdgsdgsfsadgdsgsfdsfdsfsdf&quot; //随便命名一些规则router.get(&#x27;/login&#x27;, function(req, res, next) &#123; const &#123;name,password&#125;=req.query //密码验证 if(name==userInfo.name&amp;&amp;password==userInfo.password)&#123; //生成token jwt.sign(&#123;name&#125;,jwtCode,&#123;expiresIn: &#x27;30s&#x27;&#125;,(err,token)=&gt;&#123; if(err)return res.send(err) res.json(&#123;name,msg:&quot;登陆成功&quot;,token&#125;) &#125;) &#125;else&#123; res.send(&quot;账户或密码输入错误，请重新输入&quot;) &#125;&#125;); 官网中定义的jwt.sign语法 1jwt.sign(payload, secretOrPrivateKey, [options, callback]) payload可以是表示有效 JSON 的对象文字、缓冲区或字符串。 secretOrPrivateKey是一个字符串、缓冲区或对象,其中包含 HMAC 算法的秘密或 RSA 和 ECDSA 的 PEM 编码私钥,我用于混淆token options常用： algorithm（默认HS256：） expiresIn: 如果不写单位默认为毫秒 (days, hours, etc) 1234567891011//登陆后校验tokenrouter.get(&quot;/afterlogin&quot;,function(req,res,next)&#123; const &#123;headers&#125;=req const token=headers[&quot;authorization&quot;].split(&quot; &quot;)[1] //校验方法 jwt.verify(token,jwtCode,(err,paload)=&gt;&#123; if(err) res.sendStatus(403) res.json(&#123;msg:&quot;认证成功&quot;,paload&#125;) &#125;)&#125;) 校验语法 1jwt.verify(token, secretOrPublicKey, [options, callback]) token就是前端传过来的token，一般会带上bearer，通过处理取到后面的token 参考链接http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html","categories":[{"name":"node","slug":"node","permalink":"http://www.onestyle.top/categories/node/"}],"tags":[{"name":"jwt","slug":"jwt","permalink":"http://www.onestyle.top/tags/jwt/"}]},{"title":"常用typescript","slug":"常用typescript","date":"2022-07-15T01:34:20.000Z","updated":"2024-01-17T08:01:33.094Z","comments":true,"path":"2022/07/15/常用typescript/","link":"","permalink":"http://www.onestyle.top/2022/07/15/%E5%B8%B8%E7%94%A8typescript/","excerpt":"","text":"类型声明常用1234567891011121314151617181920212223242526272829303132333435363738394041424344//booleanlet isDone: boolean = false; //stringlet name: string = &quot;bob&quot;;//numberlet decLiteral: number = 6;//数组let list: number[] = [1, 2, 3];let list: Array&lt;number&gt; = [1, 2, 3];let ro: ReadonlyArray&lt;number&gt; = a; //只读数组，除非用断言重写 //元祖let x: [string, number]; //枚举enum Color &#123;Red, Green, Blue&#125;//任意let notSure: any = 4;//voidfunction warnUser(): void &#123; console.log(&quot;This is my warning message&quot;);&#125;let unusable: void = undefined; //只能赋值undefined或null//null和undefined是所有类型的子类型let u: undefined = undefined; let n: null = null;//neverfunction error(message: string): never &#123; throw new Error(message);&#125;//对象 declare为声明一个全局变量的类型,一般在根目录下declare function create(o: object | null): void;create(&#123; prop: 0 &#125;); // OKcreate(null); // OK//解构声明类型function f([first, second]: [number, number]) &#123; console.log(first); console.log(second);&#125;//对象let &#123;a, b&#125;: &#123;a: string, b: number&#125; = o;type C = &#123; a: string, b?: number &#125;function f(&#123; a, b &#125;: C): void &#123; // ...&#125; 类型断言类型断言就是能够绕开ts的类型警告,类似一种强制执行 12let someValue: any = &quot;this is a string&quot;;let strLength: number = (&lt;string&gt;someValue).length; 12let someValue: any = &quot;this is a string&quot;;let strLength: number = (someValue as string).length; 接口interface对象和索引类型1234567891011//对象interface SquareConfig &#123; color?: string;//可选属性 option bags readonly x: number;//只读属性 [propName: string]: any; //SquareConfig具有不是以上的数据并且为string&#125;//索引类型，索引类型尽量使用数字统一标准，使用不同类型容易导致出现不同的结果//尽量使用只读interface StringArray &#123; readonly [index: number]: string; &#125; 数组123456//数组interface StringArray &#123; [index: number]: string;&#125;let myArray: StringArray;myArray = [&quot;Bob&quot;, &quot;Fred&quot;]; 函数12345678interface searchFn&#123; (a:number,b:string):boolean&#125;let mySearch: searchFn//名称不必相同，下方函数参数类型不写也可mySearch=function(apple:number,good:string) &#123; return true&#125; 类1234567891011interface ClockInterface &#123; currentTime: Date; setTime(d: Date);&#125;class Clock implements ClockInterface &#123; currentTime: Date; setTime(d: Date) &#123; this.currentTime = d; &#125; constructor(h: number, m: number) &#123; &#125;&#125; 继承接口123456789interface Shape &#123; color: string;&#125;interface PenStroke &#123; penWidth: number;&#125;interface Square extends Shape, PenStroke &#123; sideLength: number;&#125; 绕过接口检查的三种方式1.使用类型断言2.将对象传递给一个新变量,用这个变量进行传参3.字符串索引签名,[propName:string]:any ts本地测试 1231.全局安装ts2.tsc --init 初始化ts配置3.vscode终端 运行任务 tsc 箭头函数的类型添加 123456let getName:(x:number,y:number)=&gt;number = //上半部分function(x:number,y:number):string&#123;return x+y&#125;//总感觉在箭头函数中使用ts有点麻烦var myAdd = function (x, y) &#123; return x + y + y + &quot;&quot;; &#125;;//翻译成js","categories":[{"name":"typescript","slug":"typescript","permalink":"http://www.onestyle.top/categories/typescript/"}],"tags":[]},{"title":"react移动端双指缩放","slug":"react移动端双指缩放","date":"2022-07-12T08:22:47.000Z","updated":"2024-01-17T08:01:33.093Z","comments":true,"path":"2022/07/12/react移动端双指缩放/","link":"","permalink":"http://www.onestyle.top/2022/07/12/react%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%8F%8C%E6%8C%87%E7%BC%A9%E6%94%BE/","excerpt":"","text":"在服务端渲染的项目中，例如coop，m项目中，无法访问到本地window导致插件引入报错，所以直接引入hammerjs会导致报错：window is undefined，所以使用react-hammerjs实现双指缩放 首先我们可以简单的认为双指缩放可以实现以下三个功能 1.支持双指放大 2.支持双指放大后移动图片预览 3.支持双指缩小 我们通过查阅npm中react-hammerjs文档，看到有以下API pan 触碰 pinch 双指捏 press 按压 rotate 旋转 swipe 滑动 Tap 轻点 从而可以将三个功能解析成以下1.pinch 双指放大，双指缩小2.tap 移动预览 首先实现的是双指放大功能，图片放大通过改变css中transform属性中scale进行缩放放大 pinchstart 开始捏合 pinchend 捏合结束 pinchin 向内捏合 pinchout 向外捏合 然后是移动功能 panstart panmove panend 我们可以根据需求拆分出来 ​ 一般情况下我们认为从内到外是放大，从外到内是缩小，因而放大使用pinchin ，缩小使用pinchout事件，先实现放大功能可以这样做 1$ npm i react-hammerjs 123456//项目中引入import Hammer from &#x27;react-hammerjs&#x27;;//由于hammerjs可能会屏蔽pinch所以需要在option将他设置为true &lt;Hammer onDoubleTap=&#123;this.picControlor&#125; onPanStart=&#123;this.moveStart&#125; onPan=&#123;this.moving&#125; onTap=&#123;this.onTap&#125; onPinchIn=&#123;this.pinchIn&#125; onPinchOut=&#123;this.pinchOut&#125; onPinchStart=&#123;this.pinchStart&#125; onPinchEnd=&#123;this.pinchEnd&#125;options=&#123;&#123; recognizers: &#123; pan: &#123; enable: this.state.panEnable &#125;, pinch: &#123; enable: true &#125; &#125; &#125;&#125;&gt;&lt;img className=&#123;this.props.className ? `$&#123;this.props.className&#125; $&#123;this.state.className&#125;` : `$&#123;this.state.className&#125;`&#125; src=&#123;this.props.src&#125; onError=&#123;this.props.onError&#125; style=&#123;&#123;transform: `$&#123;this.state.transform&#125; `&#125;&#125; /&gt;&lt;/Hammer&gt; 当双指移动开始时1.第一次缩放,记录下 双指中心到图片中心的距离，方便缩放的时候计算2.第二次缩放,直接继承上次距离，但是由于move触发时，这个距离又会改变，需要在move事件中更新 123456789101112131415this.state.ParCli.w //父级的宽度this.state.ParCli.h //父级的高preStartDirX //图片的x移动距离preStartDirY //图片的y移动距离startDirX //开始移动的中心startDirY //开始移动的中心pinchStart = (e) =&gt; &#123; this.setState(&#123; isPinchPic: true, startDirX: this.state.scale == 1 ? this.state.ParCli.w / 2 - e.center.x : this.state.preStartDirX, startDirY: this.state.scale == 1 ? this.state.ParCli.h / 2 - e.center.y : this.state.preStartDirY &#125;); &#125; 缩放放大1.缩放中缩放时，如果单纯的围绕图片中心缩放太过生硬，苹果原生的缩放是围绕着双指中心进行放大，我们在此基础上加上边界限制，防止出现黑边 a.当页面放大，我们要让双指居中，因而每次放大偏移的距离就是缩放差值乘以距离 b.由于缩放会导致移动到黑边，所以需要严格限制移动的距离 2.缩放到最大,限制他为最大 123456789101112131415161718192021222324pinchOut = (e) =&gt; &#123; //缩放到最大 if (this.state.scale + 0.02 &gt; 2) &#123; this.setState(&#123; scale: 2, &#125;) &#125; else &#123; //缩放中 const &#123; scale, startDirX, startDirY &#125; = this.state let x = startDirX * (scale - 1) let y = startDirY * (scale - 1) x = this.lintFN(x, y).x y = this.lintFN(x, y).y this.setState(&#123; scale: scale + 0.02, isPinchPic: true, transform: `scale($&#123;scale&#125;) translate($&#123;x&#125;px,$&#123;y&#125;px)`, preStartDirX: this.state.startDirX, preStartDirY: this.state.startDirY, &#125;); &#125; &#125; 缩放缩小与缩放放大同理 12345678910111213141516171819202122232425pinchIn = () =&gt; &#123; if (isZoomed) return; // this.pinchStatus = &#x27;in&#x27; if (this.state.scale - 0.02 &lt; 1) &#123; this.setState(&#123; scale: 1, transform: `scale(1)`, isPinchPic: false &#125;); &#125; else &#123; const &#123; scale, ParCli, startDirX, startDirY &#125; = this.state let x = startDirX * (scale - 1) let y = startDirY * (scale - 1) x = this.lintFN(x, y).x y = this.lintFN(x, y).y this.setState(&#123; scale: scale - 0.02, transform: `scale($&#123;scale&#125;) translate($&#123;x&#125;px, $&#123;y&#125;px)`, isPinchPic: true &#125;); this.props.scrollOpen() &#125; &#125; 平移开始缩放比例不是1的时候，支持平移 思路是移动前记录下图片当前的trasfrom的x位移与y位移 1234567moveStart = (e) =&gt; &#123; this.setState(&#123; className: &#x27;&#x27; &#125;); let translateStr = e.target.style.transform; let translateArr = translateStr.match(/-?\\d+\\.?\\d+px/g); this.oldTranslate.x = parseFloat(translateArr[0], 10) || this.oldTranslate.x; this.oldTranslate.y = parseFloat(translateArr[1], 10) || this.oldTranslate.y; &#125; 平移中上方提到的preStartDirX用来缩放参考的位移也更改 123456789101112131415161718192021moving = (e) =&gt; &#123; // 获取拖拽的距离 let transX = this.oldTranslate.x + e.deltaX; let transY = this.oldTranslate.y + e.deltaY; //图片移动，暂存的位移也更改 this.setState(&#123; preStartDirX: transX + e.deltaX, preStartDirY: transY + e.deltaY &#125;) transX = this.lintFN(transX, transY).x transY = this.lintFN(transX, transY).y if (this.state.scale !== 1 || 2) &#123; this.setState(&#123; transform: `scale($&#123;this.state.scale&#125;) translate($&#123;transX&#125;px, $&#123;transY&#125;px)` &#125;); &#125; else &#123; this.setState(&#123; transform: `scale(2) translate($&#123;transX&#125;px, $&#123;transY&#125;px)` &#125;); &#125; &#125; 边界函数 ​ 边界函数就是限制move的时候防止拖出屏幕外，但是我通过计算下方应该是乘以二分之一，但是这样容易出界，四分之一研究了两天也未研究出来，下次明白了希望补全 123456789101112131415161718192021222324 lintFN = (x, y) =&gt; &#123; const &#123; scale, ParCli &#125; = this.state let Xn = (scale - 1) * 1 / 4 let Yn = (scale - 1) * 1 / 4//x轴边界 if (x &gt; ParCli.w * Xn) &#123; x = ParCli.w * Xn &#125; else if (x &lt; -ParCli.w * Xn) &#123; x = -ParCli.w * Xn &#125;//y轴边界 if (y &gt; ParCli.h * Yn) &#123; y = ParCli.h * Yn &#125; else if (y &lt; -ParCli.h * Yn) &#123; y = -ParCli.h * Yn &#125; return &#123; x: x, y: y &#125; &#125;","categories":[],"tags":[]},{"title":"git命令","slug":"git命令","date":"2022-07-12T01:56:50.000Z","updated":"2024-01-17T08:01:33.092Z","comments":true,"path":"2022/07/12/git命令/","link":"","permalink":"http://www.onestyle.top/2022/07/12/git%E5%91%BD%E4%BB%A4/","excerpt":"","text":"12345678910111213141516171819202122232425262728git remote show origin //显示远程库origin里的资源 git push origin master:develop //本地库和服务器进行关联git branch -D master develop //删除本地库developgit remote show 查看远程库git rm 文件名(包括路径) 从git中删除指定文件git config --list 看所有用户git ls-files 看已经被提交的git rm [file name] 删除一个文件git commit -a 提交当前repos的所有的改变git add [file name] 添加一个文件到git indexgit commit -v 当你用－v参数的时候可以看commit的差异git commit -m &quot;This is the message describing the commit&quot; 添加commit信息git commit -a -a是代表add，把所有的change加到git index里然后再commitgit commit -a -v 一般提交命令git log 看你commit的日志git diff 查看尚未暂存的更新git rm a.a 移除文件(从暂存区和工作区中删除)git rm --cached a.a 移除文件(只从暂存区中删除)git commit -m &quot;remove&quot; 移除文件(从Git中删除)git rm -f a.a 强行移除修改后文件(从暂存区和工作区中删除)git diff --cached 或 $ git diff --staged 查看尚未提交的更新git stash push 将文件给push到一个临时空间中git stash pop 将文件从临时空间pop下来git remote remove origin 远程仓库断开连接git remote add origin git@github.com:username/Hello-World.git 与远程仓库建立连接git fetch 相当于是从远程获取最新版本到本地，不会自动mergegit branch branch_0.1 master 从主分支master创建branch_0.1分支git branch -m branch_0.1 branch_1.0 将branch_0.1重命名为branch_1.0 详情看https://blog.csdn.net/halaoda/article/details/78661334 切换分支，管理暂存的代码例如我们正在一个分支进行开发，但是另一个分支的需要进行上线，而切换到另一个分支，此时必须commit，才能够切换， 使用 12345678910111213141516171819git stash // 将本地改动暂存到“栈”里面 git stash pop // 再将刚才暂存到“栈”里面的代码取出来git branch // 查看当前分支 git stash // 将本地改动暂存到“栈”里面 git checkout master // 切换到master分支 git pull // 拉取master分支最新的代码,当我们再想切换回当前的feature分支 git checkout feature // 切换回到feature分支 git stash pop // 再将刚才暂存到“栈”里面的代码取出来,这样就可以继续接着刚才的业务逻辑继续开发了 原文链接：https://blog.csdn.net/CherryLee_1210/article/details/108298304 git pull 强制覆盖本地从远程仓库下载最新版本 git fetch –all 将本地设为刚获取的最新的内容 git reset –hard origin&#x2F;master 删除分支12345查看本地分支 ： git branch 删除本地已合并的分支： git branch -d [branchname] 删除远程分支: git push origin --delete [branchname] commit之后发现错了不想提交12git reset HEAD -- . //一次性撤销所有放入残存去的文件git reset HEAD -- filename //撤销指定目标文件 回退到上一个版本12345git reset --hard headgit reset --hard 版本好git reflog 查看版本号git reset HEAD^ //把提交撤回,文件还是处于commit之前状态 删除本地仓库未pull master代码直接合并develop 背景： 本地从master新建分支，jira-1234，但是本地master不是最新的，然后在分支上修改后，直接合并到了develop， 此时，只需要把master合并到jira分支上，然后将jira合并到devleop就可以了 部署 123456789//首先切换到自己分支 git checkout 分支名称 git status git add . git commit -m &quot;注释&quot; git push origin &quot;分支名&quot; git checkout develop //切换到主分支 git pull origin develop git merge &quot;次分支&quot; --no-ff -m &quot;注释名称&quot; git push origin &quot;主分支名称&quot; git checkout jira-2554 //切换回来分支 没有在开发分支上开发,直接在测试分值上开发,并且已经commit了怎么办12341.git reset HEAD^ //把上次提交恢复到未提交状态 2.git stash 放置暂存区 3.git checkout &quot;目标分支上&quot; 4.git stash pop 多人协作开发思路：将自己代码切换到master拉一下最新代码在master里面pull更新到最新代码在develop里面pull到最新代码然后合并到develop进行测试 12345678910git checkout 分支名称 git merge master --no-ff -m &quot;&quot; git status git add . git commit -m &quot;注释&quot; git push origin &quot;分支名&quot; //这里从自己的jira里面切换到develop git checkout develop git pull origin develop git merge //分支 --no-ff -m &quot;&quot;//注释 ，有规则情况可能要加:fix，这种情况去gitlab看别人怎么注释的 git push origin develop git checkout jira-2554 //切换回来分支 gitHub连不上去手动设置hashhttps://ipaddress.com/website/www.github.com这个网站中搜索[github.com](https://ipaddress.com/website/github.com)的ip 然后在C:\\Windows\\System32\\Drivers\\etc 添加，将查找的ip替换以下的ip #github 140.82.114.4 github.com 199.232.69.194 github.global.ssl.fastly.net 教学https://www.cnblogs.com/lifexy/p/8353040.html 自动获取设置hash的ip​ 具体教学是在gitee中看到的，由于不会使用safari的历史记录就找不到了，上链接http://www.electronjs.org/apps/switchhosts 目前用于github的连接，偶尔不稳定 如果不起作用，清空一下dns缓存 123456在 Windows 下命令行执行：ipconfig /flushdns在 macOS 下执行命令：sudo killall -HUP mDNSResponder//修复键盘sudo killall -STOP -c usbd 将vscode的终端启动默认项改为git bash\\1. 在首选项中搜索shell.windows， 2.在default profile：windows中的选项改为git bash 3.找到setting.json中添加 1234&quot;terminal.integrated.profiles.windows&quot;: &#123; &quot;Git-Bash&quot;: &#123; &quot;path&quot;: &quot;D:\\\\Git\\\\bin\\\\bash.exe&quot;, &#125;, &quot;PowerShell -NoProfile&quot;: &#123; &quot;source&quot;: &quot;PowerShell&quot;, &quot;args&quot;: [&quot;-NoProfile&quot;] &#125; &#125;, &quot;terminal.integrated.defaultProfile.windows&quot;: &quot;Git-Bash&quot;, 4.如果有以下一行记得注释 “terminal.integrated.shell.windows”: “C:\\windows\\Sysnative\\cmd.exe” 5.重启vscode git断开远程仓库git remote remove origin git eslit报错1git commit --no-verify -m &quot;更新物料&quot; 这样提交就可以了 git拉取不同版本12git log //获取之前的分支日志查看后面的版本号git checkout 版本号(类似这样:d4e86275490ace7d30ba731e7b2d95d2310bbe77) //就可以了 换电脑拉不下另一台电脑的分支 12git branch -a //查看连接的分支git fetch // 更新远程分支","categories":[{"name":"git","slug":"git","permalink":"http://www.onestyle.top/categories/git/"}],"tags":[]},{"title":"编码","slug":"编码","date":"2022-07-11T10:40:10.000Z","updated":"2024-01-17T08:01:33.095Z","comments":true,"path":"2022/07/11/编码/","link":"","permalink":"http://www.onestyle.top/2022/07/11/%E7%BC%96%E7%A0%81/","excerpt":"","text":"utf-8支持所有国家的语言，一个单词支持存储8位 1个字节，中文存储24位 3个字节，但是这种用汉文读取较慢 CJK中日韩统一编码 GB2312是国内常用的编码，支持国内的所有字符，但是不支持其他国的语言，为了区分中文，将其最高位都设定成1 GBKGB2312的基础上进行扩容，所有的编码都是双字节，中英文都为12字符 GB18030基于GBK进行扩容添加藏文，蒙文等 转化他们之间的转化都需要Unicode码进行转化中文编码GB18030和GBK支持向下兼容，添加的新字符一般添加位 建议如果只针对国内的网站使用gb2312就够了如果英文多建议使用utf-8节省空间 如需扩展请看","categories":[],"tags":[]},{"title":"hexo使用","slug":"hexo使用","date":"2022-07-11T07:46:12.000Z","updated":"2024-01-17T08:01:33.092Z","comments":true,"path":"2022/07/11/hexo使用/","link":"","permalink":"http://www.onestyle.top/2022/07/11/hexo%E4%BD%BF%E7%94%A8/","excerpt":"","text":"配置详细请看 1.hexo安装 123$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install 2.选主题（可跳过） 3.一键式部署 1$ npm install hexo-deployer-git --save 1234567_config.yml 文件deploy: type: git //提交工具 repo: &lt;repository url&gt; # https://bitbucket.org/JohnSmith/johnsmith.bitbucket.io //git地址，用的是ssh，前提要先把ssh配置了 branch: [branch] message: [message] //commit 信息 1$ npm run build -d # 文件生成之后立即部署文件 注意，gitpage的名称必须是github的用户名+github.io 命令12345$ hexo new 文件名 #新建文档$ hexo s #启用本地服务器$ hexo d #自动生成静态文件并部设定仓库$ hexo clean #清除缓存和生成的public$ hexo g #生成静态文件到public文件 修改主页 凡是涉及根目录_config.yml的配置，需要重启项目才生效 修改注意一下换行和缩进，换行不对会导致报错 node_modules&#x3D;&gt;hero-theme-volantis&#x3D;&gt;_config.yml文件中进行修改 文档中markdown格式 123456789102.添加影视 &#123;% vimeo 82090131 %&#125;或&#123;% youtube TIbZDRXM-Tg %&#125;3.注释&#123;% codeblock Array.map %&#125;array.map(callback[, thisArg])&#123;% endcodeblock %&#125;","categories":[],"tags":[]},{"title":"www.google.com","slug":"link-post-without-title","date":"2013-12-24T15:44:13.000Z","updated":"2024-01-17T08:01:33.093Z","comments":true,"path":"2013/12/24/link-post-without-title/","link":"http://www.google.com/","permalink":"http://www.onestyle.top/2013/12/24/link-post-without-title/","excerpt":"","text":"This is a link post without a title. The title should be the link with or without protocol. Clicking on the link should open Google in a new tab or window.","categories":[],"tags":[]}],"categories":[{"name":"软件","slug":"软件","permalink":"http://www.onestyle.top/categories/%E8%BD%AF%E4%BB%B6/"},{"name":"学习方法","slug":"学习方法","permalink":"http://www.onestyle.top/categories/%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"},{"name":"node","slug":"node","permalink":"http://www.onestyle.top/categories/node/"},{"name":"typescript","slug":"typescript","permalink":"http://www.onestyle.top/categories/typescript/"},{"name":"git","slug":"git","permalink":"http://www.onestyle.top/categories/git/"}],"tags":[{"name":"原创","slug":"原创","permalink":"http://www.onestyle.top/tags/%E5%8E%9F%E5%88%9B/"},{"name":"游戏","slug":"游戏","permalink":"http://www.onestyle.top/tags/%E6%B8%B8%E6%88%8F/"},{"name":"vue","slug":"vue","permalink":"http://www.onestyle.top/tags/vue/"},{"name":"js","slug":"js","permalink":"http://www.onestyle.top/tags/js/"},{"name":"mixin","slug":"mixin","permalink":"http://www.onestyle.top/tags/mixin/"},{"name":"patch-package","slug":"patch-package","permalink":"http://www.onestyle.top/tags/patch-package/"},{"name":"网络","slug":"网络","permalink":"http://www.onestyle.top/tags/%E7%BD%91%E7%BB%9C/"},{"name":"宝塔","slug":"宝塔","permalink":"http://www.onestyle.top/tags/%E5%AE%9D%E5%A1%94/"},{"name":"运维","slug":"运维","permalink":"http://www.onestyle.top/tags/%E8%BF%90%E7%BB%B4/"},{"name":"chatgpt","slug":"chatgpt","permalink":"http://www.onestyle.top/tags/chatgpt/"},{"name":"AI","slug":"AI","permalink":"http://www.onestyle.top/tags/AI/"},{"name":"硬件","slug":"硬件","permalink":"http://www.onestyle.top/tags/%E7%A1%AC%E4%BB%B6/"},{"name":"微信小程序","slug":"微信小程序","permalink":"http://www.onestyle.top/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"jwt","slug":"jwt","permalink":"http://www.onestyle.top/tags/jwt/"}]}